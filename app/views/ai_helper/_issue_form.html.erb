<% if @project and @project.module_enabled?(:ai_helper) and User.current.allowed_to?({ controller: :ai_helper, action: :chat_form }, @project) and AiHelperSetting.find_or_create.model_profile %>
<script>
    // Function to toggle the open/closed state of a fieldset
    // flag: true to expand, false to collapse
    function aiHelperSetReplyExpanded(flag) {
        const fieldset = document.getElementById('ai-helper-reply-fields');
        const legend = fieldset.querySelector('legend');
        isOpen = !fieldset.classList.contains('collapsed');
        if (isOpen !== flag) {
            toggleFieldset(legend);
        }
    };

    // Function to save the open/closed state of the fieldset
    function aiHelperSaveReplyState() {
        const fieldset = document.getElementById('ai-helper-reply-fields');
        const isOpen = !fieldset.classList.contains('collapsed');
        const state = { replyExpanded: isOpen };
        localStorage.setItem('aiHelperReplyState', JSON.stringify(state));
    }

    // Load the saved state from localStorage when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        const state = localStorage.getItem('aiHelperReplyState');
        if (state) {
            const parsedState = JSON.parse(state);
            if (parsedState.replyExpanded) {
                aiHelperSetReplyExpanded(true);
            } else {
                aiHelperSetReplyExpanded(false);
            }
        }
    });
</script>
<fieldset id="ai-helper-reply-fields" class="collapsible collapsed">
    <legend onclick="toggleFieldset(this);aiHelperSaveReplyState();" class="icon icon-collapsed">
    <%= sprite_icon("angle-right") %>
    <strong>
        <%= sprite_icon("ai-helper-robot", plugin: :redmine_ai_helper)%>
        <%= l('ai_helper.generate_issue_reply.title') %>
    </strong>
    </legend>
    <div class="ai-helper-generate_reply" style="display: none;">

        <%= l('ai_helper.generate_issue_reply.instructions') %>:<br>
        <p>
        <%= text_area_tag "ai-helper-reply-instructions", "", rows: 6, style: "width: 100%;" %>
        </p>

        <%= button_tag l(:button_create), id: "ai-helper-generate-reply-btn", onclick: "ai_helper_generate_reply(#{@issue.id}); return false;" %>

        <div id="ai-helper-generate_reply-area" style="display: none;">
            <div class="loader"><%=  l(:ai_helper_loading) %></div>
        </div>

    </div>
</fieldset>

<script>
    function ai_helper_generate_reply(issue_id) {
        const instructions = document.getElementById("ai-helper-reply-instructions").value;
        const url = "<%= ai_helper_generate_issue_reply_path(id: @issue.id)%>";
        const xhr = new XMLHttpRequest();
        xhr.open('POST', url, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
        if (csrfToken) {
            xhr.setRequestHeader('X-CSRF-Token', csrfToken);
        }

        // Set response type for streaming
        xhr.responseType = 'text';

        const replyArea = document.getElementById('ai-helper-generate_reply-area');
        replyArea.style.display = '';
        
        // Initialize streaming response area
        const streamingContent = document.createElement('div');
        streamingContent.id = 'ai-helper-streaming-reply';
        streamingContent.style.border = '1px solid #ccc';
        streamingContent.style.padding = '10px';
        streamingContent.style.marginTop = '10px';
        streamingContent.style.backgroundColor = '#f9f9f9';
        streamingContent.style.minHeight = '100px';
        streamingContent.style.whiteSpace = 'pre-wrap';
        streamingContent.style.fontFamily = 'monospace';
        
        const loader = document.createElement('div');
        loader.className = 'loader';
        loader.innerHTML = '<%= j l(:ai_helper_loading) %>';
        
        replyArea.innerHTML = '';
        replyArea.appendChild(loader);
        replyArea.appendChild(streamingContent);

        let fullResponse = '';
        let buffer = '';
        let lastProcessedIndex = 0;

        xhr.onprogress = function (event) {
            const text = xhr.responseText.substring(lastProcessedIndex);
            lastProcessedIndex = xhr.responseText.length;
            buffer += text;

            // Extract data from Server-Sent Events
            const matches = buffer.match(/^data: (.+?)\n\n/gm);
            if (matches) {
                matches.forEach(match => {
                    try {
                        const dataStr = match.replace(/^data: /, '').trim();
                        const data = JSON.parse(dataStr);

                        // Get content from chunk
                        const content = data.choices[0]?.delta?.content;
                        if (content) {
                            fullResponse += content;
                            streamingContent.textContent = fullResponse;
                            
                            // Hide loader on first content
                            if (loader.style.display !== 'none') {
                                loader.style.display = 'none';
                            }
                        }

                        // Handle completion
                        if (data.choices[0]?.finish_reason === 'stop') {
                            // Create apply button
                            const applyButton = document.createElement('button');
                            applyButton.textContent = '<%= l(:button_apply) %>';
                            applyButton.style.marginTop = '10px';
                            applyButton.style.marginRight = '10px';
                            applyButton.onclick = function() {
                                const issueNotes = document.getElementById("issue_notes");
                                if (issueNotes) {
                                    issueNotes.value = fullResponse;
                                }
                            };
                            
                            // Create copy button
                            const copyButton = document.createElement('button');
                            copyButton.textContent = '<%= l(:button_copy) %>';
                            copyButton.style.marginTop = '10px';
                            copyButton.onclick = function() {
                                navigator.clipboard.writeText(fullResponse).then(function() {
                                    copyButton.textContent = '<%= l(:copied) %>';
                                    setTimeout(function() {
                                        copyButton.textContent = '<%= l(:button_copy) %>';
                                    }, 2000);
                                });
                            };
                            
                            replyArea.appendChild(applyButton);
                            replyArea.appendChild(copyButton);
                        }
                    } catch (e) {
                        console.error('Parse error:', e);
                    }

                    // Remove processed data from buffer
                    buffer = buffer.replace(match, '');
                });
            }
        };

        xhr.onerror = function () {
            loader.style.display = 'none';
            streamingContent.textContent = '<%= l(:error_occurred) %>';
        };

        xhr.onload = function () {
            if (xhr.status !== 200) {
                loader.style.display = 'none';
                streamingContent.textContent = `Error: ${xhr.status} ${xhr.statusText}`;
            }
        };

        xhr.send(JSON.stringify({ instructions: instructions }));
    };
</script>


<% end %>
